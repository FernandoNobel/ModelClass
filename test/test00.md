``` MATLAB
m = model();

m.vars
m.eqns
%% 2. Simulation

s = SimulationClass(m);

t = [0 10];

p.k1 = 1.0;
p.k2 = 1.0;
p.k3 = 1.0;
p.gamma12 = 1.0;
p.d1 = 1.0;
p.d2 = 1.0;
p.d3 = 1.0;

x0.x1 = 0.000000;
x0.x2 = 0.000000;
x0.x3 = 0.000000;

opt = odeset('AbsTol', 1e-8, 'RelTol', 1e-8);

[out] = s.simulate(t,x0,p,opt);

out

s.createOdeFunction();
```

```
ans =
 
  x1
  x2
  x3
 ref
 
 
ans =
 
    d_x1 == k1 - d1*x1 - gamma12*x1*x2
 d_x2 == k2*x3 - d2*x2 - gamma12*x1*x2
                 d_x3 == k3*x1 - d3*x3
                          ref == k3/d3
 

out = 

  struct with fields:

      t: [154x1 double]
     x1: [154x1 double]
     x2: [154x1 double]
     x3: [154x1 double]
    ref: [154x1 double]
```

# Autogenerate ode function

``` shcat modelOdeFun.m
```

```
function [dxdt] =  modelOdeFun(t,x,p)
%% MODELODEFUN Function that evaluates the ODEs of model.
% This function was autogenerated by the SimulationClass.
%
% param: t Current time in the simulation.
%      : x Vector with states values.
%      : p Struct with the parameters.
%
% return: dxdt Vector with derivatives values.

% States
% x(1,:) = x1
% x(2,:) = x2
% x(3,:) = x3
% x(4,:) = ref	 % (Algebraic state)

% der(x1) (No negative)
dxdt(1,1) = p.k1-p.d1.*x(1,:)-p.gamma12.*x(1,:).*x(2,:);

% Check if the state tries to be negative.
if x(1,1) <= 0.0 && dxdt(1,1) <= 0.0
	dxdt(1,1) = 0.0;
end

% der(x2) (No negative)
dxdt(2,1) = -p.d2.*x(2,:)+p.k2.*x(3,:)-p.gamma12.*x(1,:).*x(2,:);

% Check if the state tries to be negative.
if x(2,1) <= 0.0 && dxdt(2,1) <= 0.0
	dxdt(2,1) = 0.0;
end

% der(x3) (No negative)
dxdt(3,1) = -p.d3.*x(3,:)+p.k3.*x(1,:);

% Check if the state tries to be negative.
if x(3,1) <= 0.0 && dxdt(3,1) <= 0.0
	dxdt(3,1) = 0.0;
end

% der(ref) (Algebraic state)
dxdt(4,1) = -x(4,:)+p.k3./p.d3;

end
```
